begin;

create extension if not exists "pgcrypto";

create table if not exists public.users (
  id uuid primary key default auth.uid(),
  display_name text,
  units text check (units in ('metric','imperial')),
  created_at timestamptz not null default now()
);

create table if not exists public.leagues (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  stepweek_start text not null check (stepweek_start in ('mon','sun')),
  invite_code text not null unique,
  owner_id uuid not null references public.users(id),
  created_at timestamptz not null default now()
);

create table if not exists public.memberships (
  league_id uuid not null references public.leagues(id) on delete cascade,
  user_id uuid not null references public.users(id) on delete cascade,
  role text not null default 'member' check (role in ('owner','admin','member')),
  joined_at timestamptz not null default now(),
  primary key (league_id, user_id)
);

create table if not exists public.submissions (
  id uuid primary key default gen_random_uuid(),
  league_id uuid not null references public.leagues(id) on delete cascade,
  user_id uuid not null references public.users(id) on delete cascade,
  for_date date not null,
  steps integer not null check (steps >= 0),
  partial boolean not null default false,
  proof_path text,
  verified boolean not null default false,
  tolerance_used integer,
  extracted_km numeric(7,3),
  extracted_calories integer,
  verification_notes text,
  created_at timestamptz not null default now(),
  unique (league_id, user_id, for_date)
);

create table if not exists public.audit_log (
  id bigint generated by default as identity primary key,
  actor_id uuid references public.users(id),
  action text not null,
  target_id uuid,
  details jsonb,
  created_at timestamptz not null default now()
);

create index if not exists memberships_user_idx on public.memberships (user_id);
create index if not exists memberships_league_idx on public.memberships (league_id);
create index if not exists submissions_league_date_idx on public.submissions (league_id, for_date desc);
create index if not exists submissions_user_date_idx on public.submissions (user_id, for_date desc);
create index if not exists submissions_verified_idx on public.submissions (league_id, verified, for_date desc);
create index if not exists audit_log_target_idx on public.audit_log (target_id, created_at desc);

alter table public.users enable row level security;
alter table public.leagues enable row level security;
alter table public.memberships enable row level security;
alter table public.submissions enable row level security;
alter table public.audit_log enable row level security;

drop policy if exists "users_select_self" on public.users;
create policy "users_select_self" on public.users
  for select using (auth.uid() = id);

drop policy if exists "users_insert_self" on public.users;
create policy "users_insert_self" on public.users
  for insert with check (auth.uid() = id);

drop policy if exists "users_update_self" on public.users;
create policy "users_update_self" on public.users
  for update using (auth.uid() = id) with check (auth.uid() = id);

drop policy if exists "leagues_member_select" on public.leagues;
create policy "leagues_member_select" on public.leagues
  for select using (
    exists (
      select 1 from public.memberships m
      where m.league_id = public.leagues.id and m.user_id = auth.uid()
    )
  );

drop policy if exists "leagues_owner_insert" on public.leagues;
create policy "leagues_owner_insert" on public.leagues
  for insert with check (auth.uid() = owner_id);

drop policy if exists "leagues_owner_update" on public.leagues;
create policy "leagues_owner_update" on public.leagues
  for update using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

drop policy if exists "memberships_select_self_or_league" on public.memberships;
create policy "memberships_select_self_or_league" on public.memberships
  for select using (
    auth.uid() = user_id
    or exists (
      select 1 from public.memberships m2
      where m2.league_id = public.memberships.league_id and m2.user_id = auth.uid()
    )
  );

drop policy if exists "memberships_insert_self" on public.memberships;
create policy "memberships_insert_self" on public.memberships
  for insert with check (auth.uid() = user_id);

drop policy if exists "memberships_owner_manage_roles" on public.memberships;
create policy "memberships_owner_manage_roles" on public.memberships
  for update using (
    exists (
      select 1 from public.memberships m2
      where m2.league_id = public.memberships.league_id
        and m2.user_id = auth.uid()
        and m2.role in ('owner','admin')
    )
  )
  with check (
    exists (
      select 1 from public.memberships m2
      where m2.league_id = public.memberships.league_id
        and m2.user_id = auth.uid()
        and m2.role in ('owner','admin')
    )
  );

drop policy if exists "submissions_league_read" on public.submissions;
create policy "submissions_league_read" on public.submissions
  for select using (
    exists (
      select 1 from public.memberships m
      where m.league_id = public.submissions.league_id and m.user_id = auth.uid()
    )
  );

drop policy if exists "submissions_insert_self" on public.submissions;
create policy "submissions_insert_self" on public.submissions
  for insert with check (auth.uid() = user_id);

drop policy if exists "submissions_update_self" on public.submissions;
create policy "submissions_update_self" on public.submissions
  for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

drop policy if exists "audit_log_read_service_role" on public.audit_log;
create policy "audit_log_read_service_role" on public.audit_log
  for select using (auth.role() = 'service_role');

drop policy if exists "audit_log_insert_service_role" on public.audit_log;
create policy "audit_log_insert_service_role" on public.audit_log
  for insert with check (auth.role() = 'service_role');

create or replace function public.leaderboard_period(
  _league_id uuid,
  _dates date[],
  _limit integer default 50,
  _offset integer default 0
) returns table (
  rank integer,
  user_id uuid,
  display_name text,
  total_steps bigint,
  total_km numeric(12,3),
  total_calories bigint,
  partial_days integer,
  missed_days integer,
  verified_days integer,
  unverified_days integer,
  member_total integer,
  team_total_steps bigint
)
language plpgsql
security invoker
as $$
declare
  expected_days integer;
  limit_value integer := coalesce(_limit, 50);
  offset_value integer := greatest(coalesce(_offset, 0), 0);
begin
  if array_length(_dates, 1) is null or array_length(_dates, 1) = 0 then
    raise exception 'dates array cannot be empty';
  end if;

  if not exists (
    select 1 from public.memberships m
    where m.league_id = _league_id and m.user_id = auth.uid()
  ) then
    raise exception 'permission denied for league %', _league_id using errcode = '42501';
  end if;

  expected_days := (
    select count(distinct d)::int
    from unnest(_dates) as d
  );

  return query
    with selected_dates as (
      select distinct d::date as for_date
      from unnest(_dates) as d
    ),
    scoped_submissions as (
      select s.*
      from public.submissions s
      where s.league_id = _league_id
        and s.for_date in (select for_date from selected_dates)
    ),
    member_base as (
      select
        m.user_id,
        coalesce(u.display_name, 'Member') as display_name
      from public.memberships m
      left join public.users u on u.id = m.user_id
      where m.league_id = _league_id
    ),
    aggregated as (
      select
        mb.user_id,
        mb.display_name,
        coalesce(sum(case when ss.verified is true then ss.steps else 0 end), 0)::bigint as total_steps,
        coalesce(sum(case when ss.verified is true then coalesce(ss.extracted_km, 0::numeric) else 0::numeric end), 0)::numeric(12,3) as total_km,
        coalesce(sum(case when ss.verified is true then coalesce(ss.extracted_calories, 0) else 0 end), 0)::bigint as total_calories,
        count(*) filter (where ss.verified is true and ss.partial) as partial_days,
        count(distinct case when ss.verified is true then ss.for_date end) as verified_days,
        count(distinct case when ss.verified is not true and ss.id is not null then ss.for_date end) as unverified_days
      from member_base mb
      left join scoped_submissions ss on ss.user_id = mb.user_id
      group by mb.user_id, mb.display_name
    ),
    ranked as (
      select
        row_number() over (order by aggregated.total_steps desc, aggregated.total_km desc, aggregated.user_id) as row_rank,
        aggregated.*
      from aggregated
    ),
    stats as (
      select
        (select count(*) from member_base) as member_total,
        (select coalesce(sum(total_steps), 0)::bigint from aggregated) as team_total_steps
    )
    select
      ranked.row_rank,
      ranked.user_id,
      ranked.display_name,
      ranked.total_steps,
      ranked.total_km,
      ranked.total_calories,
      ranked.partial_days,
      greatest(expected_days - ranked.verified_days, 0) as missed_days,
      ranked.verified_days,
      ranked.unverified_days,
      stats.member_total,
      stats.team_total_steps
    from ranked
    cross join stats
    where ranked.row_rank > offset_value
    order by ranked.row_rank
    limit limit_value;
end;
$$;

commit;